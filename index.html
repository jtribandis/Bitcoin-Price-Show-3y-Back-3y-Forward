<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bitcoin Price — Show 3y Back / 3y Forward</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script>
/* Inline minimal Chart.js subset loader via CDN fallback if blocked */
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root { --bg:#0b0b0f; --card:#151823; --muted:#8b94a7; --text:#e7ecf5; --accent:#69d5a5; --warn:#f6c833; }
  * { box-sizing: border-box; }
  body { margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; background:linear-gradient(180deg,#090a0f,#0f1320 40%,#0b0b0f); color:var(--text);}
  .wrap { max-width:1200px; margin:40px auto; padding:0 16px; }
  h1 { font-size: clamp(24px, 4vw, 34px); margin:0 0 8px; }
  p.lead { color:var(--muted); margin:0 0 18px; }
  .card { background: var(--card); border:1px solid #21263a; border-radius:16px; padding:16px; box-shadow: 0 6px 20px rgba(0,0,0,.25);}
  .controls { display:flex; flex-wrap:wrap; gap:12px; margin-top:12px; align-items:center; }
  .control { background:#0f1220; border:1px solid #242a3f; border-radius:10px; padding:10px 12px; color:var(--text); }
  label { font-size:12px; color:var(--muted); margin-right:6px; }
  select{ background:#0f1220; border:1px solid #242a3f; border-radius:10px; padding:8px 10px; color:#e7ecf5; }
  button.primary { background:var(--accent); color:#062b1b; border:none; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer; }
  button.ghost { background:transparent; border:1px solid #2a3050; color:#e7ecf5; border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer; }
  .row { display:grid; grid-template-columns: 1.25fr .75fr; gap:16px; margin-top:16px; }
  @media (max-width: 1100px) { .row { grid-template-columns: 1fr; } }
  .statgrid { display:grid; grid-template-columns: repeat(4, minmax(150px,1fr)); gap:12px; margin-top:12px; }
  .stat { background:#0f1220; border:1px solid #262c40; border-radius:12px; padding:10px; }
  .stat b { display:block; font-size:12px; color:#aeb7cc; }
  .stat span { font-size:16px; font-weight:700; }
  code { background:#0f1220; padding:2px 6px; border-radius:6px; }
  footer { color:var(--muted); font-size:12px; margin-top:14px; }
  .muted { color:var(--muted); }
  .smallgrid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  @media (max-width: 1100px) { .smallgrid { grid-template-columns: 1fr; } }
  .grade { font-weight:800; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Bitcoin Price — Show 3y Back / 3y Forward</h1>
  <p class="lead">Using bitcoin price data since 2018 for multi‑frequency tests.</p>

  <div class="row">
    <div class="card">
      <canvas id="chart" height="420"></canvas>
      <div class="controls">
        <div class="control">
          <label>Fit frequency</label>
          <select id="freq">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly" selected>Monthly</option>
            <option value="annual">Annual</option>
          </select>
        </div>
        <div class="control">
          <label>Vol level (× baseline)</label>
          <input id="volLevel" type="range" min="0" max="2" step="0.05" value="1" />
          <span id="volLevelVal">1.00×</span>
        </div>
        <button id="btnRandom" class="primary">Randomize Volatility</button>
        <button id="btnToggle" class="ghost">Hide Volatility</button>
        <button id="btnReload" class="ghost">Reload Live</button>
        <button id="btnReloadStats" class="ghost">Reload Stats</button>
        <span id="status" style="margin-left:auto;color:#9fb0ff;font-size:12px"></span>
      </div>
      <footer class="muted">X-axis shows short dates every 6 months (1/YY and 7/YY). Y-axis min auto-sets to the lowest value across history + forecast. Volatility path is endpoint-anchored.</footer>
    </div>

    <div class="card">
      <h3>Parameters & Evaluation</h3>
      <div class="statgrid">
        <div class="stat"><b>P₀ (fit start)</b><span id="p0">$—</span></div>
        <div class="stat"><b>Today price (join)</b><span id="pend">$—</span></div>
        <div class="stat"><b>g_p (per freq)</b><span id="gp_freq">—</span></div>
        <div class="stat"><b>d_p (per freq)</b><span id="dp_freq">—</span></div>
        <div class="stat"><b>g_p (per month)</b><span id="gp_month">—</span></div>
        <div class="stat"><b>d_p (per month)</b><span id="dp_month">—</span></div>
        <div class="stat"><b>Half-life (freq units)</b><span id="hl_freq">—</span></div>
        <div class="stat"><b>In‑sample R²</b><span id="r2">—</span></div>
        <div class="stat"><b>CV RMSE (log)</b><span id="rmse">—</span></div>
        <div class="stat"><b>σ baseline (per freq)</b><span id="sig_freq">—</span></div>
        <div class="stat"><b>σ baseline (per month)</b><span id="sig_month">—</span></div>
        <div class="stat"><b>AIC / BIC</b><span id="aicbic">—</span></div>
        <div class="stat"><b>Adj (CV folds)</b><span id="adj">—</span></div>
        <div class="stat"><b>Predictive grade</b><span id="grade" class="grade">—</span></div>
      </div>
      <div class="muted" style="margin-top:8px">
        <b>Notes</b>
        <ul style="margin-top:6px; line-height:1.35">
          <li><b>Daily under‑performs:</b> Gompertz is a slow macro curve; daily BTC has high micro‑noise (news, order‑flow, microstructure). One‑step‑ahead daily forecasts ≈ random → low R² and high CV RMSE.</li>
          <li><b>Annual looks strong (statistically):</b> Aggregation smooths volatility; the multi‑year adoption/halving trend dominates annually, so residual variance falls and fit improves.</li>
          <li><b>Display vs estimation:</b> The forecast is <i>displayed monthly</i> for readability, but parameters are estimated at the frequency you pick (daily/weekly/monthly/annual). An <i>annual</i> fit still renders as a smooth monthly curve; frequency only changes how the parameters are learned.</li>
          <li><b>Macro rationale for ~$200k:</b> Recent 5‑yr growth averaged ~60% YoY, but at multi‑trillion‑dollar scale growth should slow. Many institutional outlooks see ~25% YoY as very bullish → a 3‑year path near $200k is financially plausible even if daily statistical metrics are weak.</li>
          <li><b>Sample‑size caveat:</b> Annual since 2018 has few observations → fewer CV folds and optimism risk. We down‑weight the grade by a <i>folds adjustment</i> (see “Adj (CV folds)”). Monthly is a balanced middle‑ground.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Why we don’t use averages → Visual proofs</h3>
    <div class="smallgrid">
      <div>
        <canvas id="sseChart" height="220"></canvas>
        <p class="muted">Loss vs <code>d</code>. We select the <code>d</code> that minimizes SSE; this determines <code>d_p</code> (MLE under Gaussian errors).</p>
      </div>
      <div>
        <canvas id="yzChart" height="220"></canvas>
        <p class="muted">Scatter of <code>y</code> vs <code>z_d</code> with fitted line <code>ŷ = β z_d</code>. Through‑origin OLS uses <code>β = Σ(z·y)/Σ(z²)</code>; then <code>g_p=β·d</code>.</p>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Variable Index — Gompertz</h3>
    <div class="muted">
      <p><b>β (slope):</b> <code>β = Σ(z·y)/Σ(z²)</code> (through‑origin OLS). <b>Then</b> <code>g_p = β·d</code>.</p>
      <p><b>P₀</b>: price at the start of the (2018→today) fit window.</p>
      <p><b>Σ(z·y)</b>: sum of <code>z_d(t)·y(t)</code> across time.</p>
      <p><b>Σ(z²)</b>: sum of <code>z_d(t)^2</code> across time.</p>
      <p><b>g_p, d_p</b>: initial log‑growth and its decay; <b>Half‑life</b>: <code>ln(2)/d_p</code>.</p>
      <p><b>Path:</b> <code>P(t)=P₀·exp((g_p/d_p)(1−e^{−d_p t}))</code>.</p>
    </div>
  </div>

  <div class="card">
    <h3>Variable Index — Brownian Bridge Volatility</h3>
    <div class="muted">
      <p><b>r</b>: log return for the selected frequency, <code>r_t=ln(P_t/P_{t-1})</code>.</p>
      <p><b>σ</b>: baseline stdev of <code>r</code> since 2018; per‑month via square‑root‑of‑time.</p>
      <p><b>B(t)</b>: bridge with <code>B(0)=B(T)=0</code> (endpoint‑anchored randomness).</p>
      <p><b>Volatile path:</b> <code>\u007eP(t)=P(t)·exp(σ·B(t))</code>.</p>
    </div>
  </div>

  <div class="card">
    <h3>Variable Index — Statistical Tools</h3>
    <div class="muted">
      <p><b>Decay selection:</b> choose <code>d_p</code> by minimizing SSE over a grid of <code>d</code>.</p>
      <p><b>CV RMSE:</b> rolling origin; fit on a growing window and score one‑step‑ahead log‑errors.</p>
      <p><b>AIC/BIC & AICc:</b> penalized likelihoods; AICc corrects AIC for small samples (<code>AICc = AIC + 2k(k+1)/(n-k-1)</code>). We still grade primarily with CV RMSE.</p>
    </div>
  </div>

  <footer class="muted">Hidden API key: use <code>?cgkey=YOUR_KEY</code> or set <code>localStorage.setItem('cgkey','YOUR_KEY')</code> and reload. Forecast uses monthly steps for display; fit & volatility baselines respect your selected frequency.</footer>
</div>

<script>
// Hidden API key
const CG_KEY = (new URLSearchParams(location.search)).get('cgkey') || localStorage.getItem('cgkey') || '';

// Helpers
const clamp01 = (x)=> Math.max(0, Math.min(1, x));
const fmtUSD = (x) => x.toLocaleString(undefined, {maximumFractionDigits:0});
const DAYS_PER_MONTH = 30.4375;
const WEEKS_PER_MONTH = 4.34524;

const monthsBetween = (d0, d1) => (d1 - d0) / (1000*60*60*24 * 30.4375);
const weeksBetween  = (d0, d1) => (d1 - d0) / (1000*60*60*24 * 7);
const daysBetween   = (d0, d1) => (d1 - d0) / (1000*60*60*24);
const yearsBetween  = (d0, d1) => (d0 ? ((d1.getFullYear() - d0.getFullYear()) + ((d1.getMonth()-d0.getMonth())/12) + ((d1.getDate()-d0.getDate())/365.25)) : 0);

// Aggregators
function toMonthly(daily) { const byYM = new Map(); daily.forEach(pt => { const y=pt.date.getFullYear(), m=pt.date.getMonth(); const key=y+'-'+m; const prev=byYM.get(key); if(!prev || pt.date>prev.date) byYM.set(key, pt); }); return Array.from(byYM.values()).sort((a,b)=> a.date-b.date); }
function isoWeekKey(d) { const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay()||7)); const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1)); const weekNo = Math.ceil((((date - yearStart)/86400000) + 1)/7); return date.getUTCFullYear() + '-W' + String(weekNo).padStart(2,'0'); }
function toWeekly(daily) { const byW = new Map(); daily.forEach(pt => { const key = isoWeekKey(pt.date); const prev = byW.get(key); if (!prev || pt.date > prev.date) byW.set(key, pt); }); return Array.from(byW.values()).sort((a,b)=> a.date-b.date); }
function toAnnual(daily) { const byY = new Map(); daily.forEach(pt => { const y=pt.date.getFullYear(); const prev=byY.get(y); if(!prev || pt.date>prev.date) byY.set(y, pt); }); return Array.from(byY.values()).sort((a,b)=> a.date-b.date); }
function to2018Daily(d){ const s=new Date(2018,0,1); return d.filter(pt=> pt.date>=s); }

// Fit (single, OLS + SSE)
function olsSlope(y,z){ let zy=0, zz=0; for (let i=0;i<y.length;i++){ zy += z[i]*y[i]; zz += z[i]*z[i]; } return zy/zz; }
function fitSingle(ts, prices){
  const P0 = prices[0];
  const y = prices.map(p => Math.log(p/P0));
  let best = {d:0.03, g:0.03, loss:Infinity, beta:0, z:[], yhat:[], y:y.slice(), P0};
  const dGrid=[], lossGrid=[];
  const step = 0.0006;
  for (let d=step; d<=0.15; d+=step) {
    const z = ts.map(t => 1 - Math.exp(-d*t));
    const beta = olsSlope(y,z);
    const yhat = z.map(v => beta*v);
    const res = y.map((yi,i)=> yi - yhat[i]);
    const L = res.reduce((s,e)=>s+e*e,0); // SSE
    dGrid.push(d); lossGrid.push(L);
    if (L < best.loss) best = {d, g: beta*d, loss:L, beta, z, yhat, y, P0};
  }
  const ybar = y.reduce((a,b)=>a+b,0)/y.length;
  let ssTot=0, ssRes=0; for (let i=0;i<y.length;i++) { ssTot+=(y[i]-ybar)**2; ssRes+=(y[i]-best.yhat[i])**2; }
  const r2 = 1 - ssRes/ssTot;
  const n=y.length; const sse = ssRes; const sigma2 = sse/n; const logL = -0.5*n*(Math.log(2*Math.PI*sigma2)+1);
  const k=2; const AIC = 2*k - 2*logL; const BIC = k*Math.log(n) - 2*logL;
  const AICc = AIC + (2*k*(k+1))/(Math.max(1, n-k-1));
  return {...best, r2, dGrid, lossGrid, AIC, BIC, AICc, n, sse};
}

// Null model (flat log price: yhat=0)
function fitNull(ts, prices){
  const P0 = prices[0];
  const y = prices.map(p => Math.log(p/P0));
  const ybar = y.reduce((a,b)=>a+b,0)/y.length;
  let ssTot=0, ssRes=0; for (let i=0;i<y.length;i++) { ssTot+=(y[i]-ybar)**2; ssRes+=(y[i]-0)**2; }
  const r2 = 1 - ssRes/ssTot;
  const n=y.length; const sse = ssRes; const sigma2 = sse/n; const logL = -0.5*n*(Math.log(2*Math.PI*sigma2)+1);
  const k=0; const AIC = 2*k - 2*logL; const BIC = k*Math.log(n) - 2*logL; const AICc=AIC;
  return {AIC,BIC,AICc,n,sse,r2};
}

// Forecast
function gompertzSeries(P0, g, d, steps){ const out=[]; for (let t=0;t<=steps;t++) out.push(P0*Math.exp((g/d)*(1-Math.exp(-d*t)))); return out; }

// Brownian bridge
function brownianBridgeStd(T){ const z = Array.from({length:T}, ()=> gaussian()); const W=[0]; let c=0; for (let i=0;i<T;i++){ c+=z[i]; W.push(c);} const WT=W[T]; const B=W.map((w,t)=> w - (t/T)*WT); const scl=Math.sqrt(T); const out=B.map(v=>v/(scl||1)); out[0]=0; out[T]=0; return out; }
function gaussian(){ let u=0,v=0; while(!u)u=Math.random(); while(!v)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

// Data sources
async function tryCG(){ const headers = CG_KEY ? {'x-cg-demo-api-key': CG_KEY} : undefined; const url='https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=max&interval=daily'; const r=await fetch(url,{headers}); if(!r.ok) throw new Error('CG '+r.status); const j=await r.json(); if(!j.prices) throw new Error('CG no prices'); return j.prices.map(([ms,p])=>({date:new Date(ms),price:p})); }
async function tryCC(){ try{ const r=await fetch('https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&allData=true'); if(!r.ok) throw new Error('CC-all '+r.status); const j=await r.json(); if(!j.Data||!j.Data.Data) throw new Error('shape'); return j.Data.Data.map(row=>({date:new Date(row.time*1000), price:row.close})); } catch(e){ const r=await fetch('https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=2000'); if(!r.ok) throw new Error('CC '+r.status); const j=await r.json(); return j.Data.Data.map(row=>({date:new Date(row.time*1000), price:row.close})); } }

// State
let DAILIES=null, WEEKLIES=null, MONTHLIES=null, ANNUALS=null;
let _histData=null, _forecast=null, _histLen=0, _volPath=null;
let _sigmaMonthly=null;
let _fit=null;
let _cacheCV = new Map(); // memoize CV: key -> {rmseLog, folds}

async function loadLive(){
  const status=document.getElementById('status'); status.textContent='Loading full-history data…';
  try{ const daily=to2018Daily(await tryCG()); status.textContent='Loaded from CoinGecko.'; DAILIES=daily; WEEKLIES=toWeekly(daily); MONTHLIES=toMonthly(daily); ANNUALS=toAnnual(daily); buildAll(); }
  catch(e1){ try{ const daily=to2018Daily(await tryCC()); status.textContent='Loaded from CryptoCompare.'; DAILIES=daily; WEEKLIES=toWeekly(daily); MONTHLIES=toMonthly(daily); ANNUALS=toAnnual(daily); buildAll(); } catch(e2){ status.textContent='Both APIs blocked.'; } }
}

function seriesForFreq(freq){
  if(freq==='daily') return DAILIES;
  if(freq==='weekly') return WEEKLIES;
  if(freq==='monthly') return MONTHLIES;
  return ANNUALS;
}
function monthsPerUnitFor(freq){
  if(freq==='daily') return 1/30.4375;
  if(freq==='weekly') return 1/4.34524;
  if(freq==='monthly') return 1;
  return 12;
}
function unitNameFor(freq){
  return (freq==='daily'?'days':(freq==='weekly'?'weeks':(freq==='monthly'?'months':'years')));
}

function buildAll(){
  const freq=document.getElementById('freq').value;

  const series = seriesForFreq(freq);
  const t0 = series[0].date;
  const tFunc = (freq==='daily')?daysBetween:(freq==='weekly')?weeksBetween:(freq==='monthly')?monthsBetween:yearsBetween;
  const monthsPerUnit = monthsPerUnitFor(freq);

  const ts = series.map(pt=> tFunc(t0, pt.date));
  const prices = series.map(pt=> pt.price);

  // Fit (OLS + SSE only)
  const fit = fitSingle(ts, prices); _fit=fit;

  // Vol baseline (per selected freq) -> monthly by sqrt(time)
  const rets=[]; for(let i=1;i<series.length;i++) rets.push(Math.log(series[i].price/series[i-1].price));
  const mean=rets.reduce((a,b)=>a+b,0)/rets.length;
  const sd=Math.sqrt(rets.reduce((s,x)=> s + (x-mean)*(x-mean), 0)/rets.length);
  const periodsPerMonth = 1/monthsPerUnit;
  _sigmaMonthly = sd * Math.sqrt(periodsPerMonth);

  // Convert g,d to monthly
  const g_month = fit.g / monthsPerUnit;
  const d_month = fit.d / monthsPerUnit;

  // Main chart (monthly last 36 + 36 forward)
  const monthlyHist = MONTHLIES.slice(-36);
  const lastPoint = monthlyHist[monthlyHist.length-1];
  const horizonMonths=36;
  const projMonthly = gompertzSeries(lastPoint.price, g_month, d_month, horizonMonths);
  const labels = monthlyHist.map(pt=> pt.date.toISOString().slice(0,10)).concat(
    Array.from({length:horizonMonths},(_,i)=> new Date(lastPoint.date.getFullYear(), lastPoint.date.getMonth()+i+1,1).toISOString().slice(0,10))
  );
  const histData = monthlyHist.map(pt=> pt.price);
  const forecast = [ lastPoint.price, ...projMonthly.slice(1) ];
  _histData=histData; _forecast=forecast; _histLen=histData.length;
  const ymin = Math.min(...histData, ...forecast); const yMinRounded = Math.max(0, Math.floor(ymin/1000)*1000);

  if(window._btcChart) window._btcChart.destroy();
  const ctx=document.getElementById('chart');
  window._btcChart = new Chart(ctx, {
    type:'line',
    data:{
      labels,
      datasets:[
        { label:`Historical (monthly, last 3y)`, data: histData.concat(new Array(forecast.length-1).fill(null)), borderColor:'#60a5fa', tension:.2, pointRadius:0, spanGaps:true },
        { label:'Gompertz (next 3y)', data: new Array(histData.length-1).fill(null).concat(forecast), borderColor:'#69d5a5', tension:.2, pointRadius:0, spanGaps:true },
        { label:'Volatile path (Brownian bridge)', data: new Array(histData.length-1).fill(null).concat(forecast.map((p,i)=> p*((_volPath||[])[i]||1))), borderColor:'#f6c833', borderDash:[6,4], tension:.25, pointRadius:0, hidden:false, spanGaps:true }
      ]
    },
    options:{
      responsive:true, interaction:{mode:'index',intersect:false},
      plugins:{ legend:{ labels:{ color:'#cdd5e7'} } },
      scales:{
        y:{ min:yMinRounded, ticks:{ color:'#cdd5e7', callback:(v)=>'$'+fmtUSD(v)}, grid:{display:false} },
        x:{ ticks:{ color:'#cdd5e7', autoSkip:false, callback:(v,i)=> short6MLabel(labels[i]) }, grid:{display:false} }
      }
    }
  });

  // Update stats & diagnostics
  updateStatsOnly({ts, prices, sd, monthsPerUnit});
  buildDiagnostics(fit);
  document.getElementById('status').textContent = `Freq: ${freq}`;
}

function buildDiagnostics(fit){
  if(window._sseChart) window._sseChart.destroy();
  const sseCtx=document.getElementById('sseChart');
  window._sseChart = new Chart(sseCtx, {
    type:'line',
    data:{ labels: fit.dGrid.map(d=>d.toFixed(3)), datasets:[{ label:'Loss(d)', data: fit.lossGrid, borderColor:'#60a5fa', pointRadius:0, tension:.15 }]},
    options:{ responsive:true, plugins:{legend:{labels:{color:'#cdd5e7'}}}, scales:{ x:{grid:{display:false}, ticks:{color:'#cdd5e7', maxTicksLimit:10}}, y:{grid:{display:false}, ticks:{color:'#cdd5e7'}} } }
  });

  if(window._yzChart) window._yzChart.destroy();
  const yzCtx=document.getElementById('yzChart');
  const z = fit.z, y = fit.y;
  const beta = fit.beta;
  const pairs=z.map((zi,i)=>({x:zi,y:y[i]})).filter(p=>p.x!==undefined).sort((a,b)=>a.x-b.x);
  const zSorted = pairs.map(p=>p.x);
  const yhatLine = zSorted.map(zi => beta*zi);
  window._yzChart = new Chart(yzCtx, {
    type:'scatter',
    data:{ datasets:[
      { label:'y vs z_d (points)', data:pairs, borderColor:'#f6c833', backgroundColor:'#f6c833', pointRadius:2, showLine:false },
      { label:'ŷ = β z_d (fit line)', data: zSorted.map((zi,i)=>({x:zi,y:yhatLine[i]})), borderColor:'#69d5a5', pointRadius:0, showLine:true, type:'line' }
    ]},
    options:{ responsive:true, plugins:{legend:{labels:{color:'#cdd5e7'}}}, scales:{ x:{grid:{display:false}, ticks:{color:'#cdd5e7'}}, y:{grid:{display:false}, ticks:{color:'#cdd5e7'}} } }
  });
}

// ---- CV cache key
function cvKey(freq, n){ return `ols|l2|single|${freq}|${n}`; }

// ---- Update stats only (no chart rebuild)
function updateStatsOnly(ctx){
  const {ts, prices, sd, monthsPerUnit} = ctx || deriveContextFromUI();
  // fit if missing
  let fit = _fit;
  if (!fit) { fit = fitSingle(ts, prices); _fit = fit; }
  const unitName = unitNameFor(document.getElementById('freq').value);

  // CV (memoized)
  const key = cvKey(document.getElementById('freq').value, prices.length);
  let cv = _cacheCV.get(key);
  if (!cv) { cv = computeCV(ts, prices); _cacheCV.set(key, cv); }

  // IC weights vs null
  const nullFit = fitNull(ts, prices);
  const aic_w = IC_weight(fit.AICc, nullFit.AICc);
  const bic_w = IC_weight(fit.BIC, nullFit.BIC);
  const ic_weight = 0.5*(aic_w + bic_w);

  // Predictive grade (0–100) — emphasize CV RMSE, with folds adjustment
  const r2_score = clamp01(fit.r2);
  const denom = sd || 1e-6; // returns stdev per frequency
  const rmse_score = clamp01(1 - (cv.rmseLog || 0)/denom);
  const base = (0.6*rmse_score + 0.3*r2_score + 0.1*ic_weight);
  const baselineFolds = 12;
  const adj = Math.max(0.4, Math.min(1, Math.sqrt((cv.folds||1)/baselineFolds))); // 0.4–1.0
  const grade = Math.round(100*base*adj);

  // Convert g,d to monthly
  const g_month = fit.g / monthsPerUnit;
  const d_month = fit.d / monthsPerUnit;

  // Update panel
  document.getElementById('p0').textContent = '$'+fmtUSD(prices[0]);
  document.getElementById('pend').textContent = (window._forecast && window._forecast[0]) ? '$'+fmtUSD(window._forecast[0]) : '—';
  document.getElementById('gp_freq').textContent = (fit.g*100).toFixed(2)+'%';
  document.getElementById('dp_freq').textContent = (fit.d*100).toFixed(2)+'%';
  document.getElementById('gp_month').textContent = (g_month*100).toFixed(2)+'%';
  document.getElementById('dp_month').textContent = (d_month*100).toFixed(2)+'%';
  document.getElementById('hl_freq').textContent = (Math.log(2)/fit.d).toFixed(1)+' '+unitName;
  document.getElementById('r2').textContent = (fit.r2||0).toFixed(3);
  document.getElementById('rmse').textContent = (cv.rmseLog||NaN).toFixed(4);
  document.getElementById('sig_freq').textContent = (sd*100).toFixed(2)+'% / '+unitName;
  document.getElementById('sig_month').textContent = ((sd*Math.sqrt(1/monthsPerUnit))*100).toFixed(2)+'% / month';
  document.getElementById('aicbic').textContent = fit.AIC.toFixed(0)+' / '+fit.BIC.toFixed(0);
  document.getElementById('adj').textContent = '×'+adj.toFixed(2)+` (folds=${cv.folds})`;
  document.getElementById('grade').textContent = grade+'/100';

  document.getElementById('status').textContent = `Updated stats | Folds: ${cv.folds}`;
}

function deriveContextFromUI(){
  const freq=document.getElementById('freq').value;
  const series = seriesForFreq(freq);
  const t0 = series[0].date;
  const tFunc = (freq==='daily')?daysBetween:(freq==='weekly')?weeksBetween:(freq==='monthly')?monthsBetween:yearsBetween;
  const monthsPerUnit = monthsPerUnitFor(freq);
  const ts = series.map(pt=> tFunc(t0, pt.date));
  const prices = series.map(pt=> pt.price);
  const rets=[]; for(let i=1;i<series.length;i++) rets.push(Math.log(series[i].price/series[i-1].price));
  const mean=rets.reduce((a,b)=>a+b,0)/rets.length;
  const sd=Math.sqrt(rets.reduce((s,x)=> s + (x-mean)*(x-mean), 0)/rets.length);
  return {ts, prices, sd, monthsPerUnit};
}

// Akaike/Bayes weight vs null; returns weight for current model
function IC_weight(AIC_curr, AIC_null){
  const d = AIC_curr - AIC_null;
  const wCurr = Math.exp(-0.5*Math.max(0,d));
  const wNull = Math.exp(-0.5*Math.max(0,-d));
  return wCurr / (wCurr + wNull);
}

// Time-series cross-validation: rolling-origin 1-step-ahead RMSE on log-price (OLS/SSE)
function computeCV(ts, prices){
  const n = prices.length;
  if (n<40) return {rmseLog: NaN, folds: 0};
  const minTrain = Math.max(24, Math.floor(n*0.3));
  const maxFolds = 12;
  const step = Math.max(1, Math.floor((n - (minTrain+2)) / maxFolds));
  const errs=[]; let folds=0;
  for (let idx=minTrain; idx<=n-2; idx+=step){
    const tsTrain = ts.slice(0, idx+1);
    const prTrain = prices.slice(0, idx+1);
    const tsNext = ts[idx+1];
    const f = fitSingle(tsTrain, prTrain);
    const g = f.g, d = f.d, P0 = prTrain[0];
    const yhat_next = (g/d) * (1 - Math.exp(-d*tsNext));
    const Phat_next = P0 * Math.exp(yhat_next);
    const e = Math.log(prices[idx+1]) - Math.log(Phat_next);
    errs.push(e);
    folds++;
  }
  const mse = errs.reduce((s,x)=> s + x*x, 0) / errs.length;
  return {rmseLog: Math.sqrt(mse), folds};
}

// Brownian bridge volatility
function brownianBridgeStd(T){ const z = Array.from({length:T}, ()=> gaussian()); const W=[0]; let c=0; for (let i=0;i<T;i++){ c+=z[i]; W.push(c);} const WT=W[T]; const B=W.map((w,t)=> w - (t/T)*WT); const scl=Math.sqrt(T); const out=B.map(v=>v/(scl||1)); out[0]=0; out[T]=0; return out; }
function gaussian(){ let u=0,v=0; while(!u)u=Math.random(); while(!v)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

function regenVolPath(forceNew=false){
  if(!_forecast) return;
  const level = parseFloat(document.getElementById('volLevel').value);
  document.getElementById('volLevelVal').textContent = level.toFixed(2)+'×';
  const T=_forecast.length-1;
  const B=brownianBridgeStd(T);
  const s = (_sigmaMonthly||0.1)*level;
  const path = B.map(v=> Math.exp(s*v));
  path[0]=1; path[T]=1;
  _volPath = path;
}
function refreshVol(){ if(!window._btcChart) return; const ds = window._btcChart.data.datasets[2]; ds.data=new Array(_histLen-1).fill(null).concat(_forecast.map((p,i)=> p*((_volPath||[])[i]||1))); window._btcChart.update(); }

// Ticks: show every 6 months (1/YY, 7/YY)
function short6MLabel(iso){ const d=new Date(iso); const m=d.getMonth(); if(m===0||m===6) return (m+1)+'/'+String(d.getFullYear()).slice(-2); return ''; }

// UI events
document.getElementById('volLevel').addEventListener('input', ()=>{ regenVolPath(); refreshVol(); });
document.getElementById('btnRandom').addEventListener('click', ()=>{ regenVolPath(true); refreshVol(); });
document.getElementById('btnToggle').addEventListener('click', (e)=>{ const ds=window._btcChart?.data.datasets[2]; if(!ds) return; ds.hidden=!ds.hidden; e.target.textContent=ds.hidden?'Show Volatility':'Hide Volatility'; window._btcChart.update(); });
document.getElementById('btnReload').addEventListener('click', ()=>{ loadLive(); });
document.getElementById('btnReloadStats').addEventListener('click', ()=>{ updateStatsOnly(); });
['freq'].forEach(id=> document.getElementById(id).addEventListener('change', ()=>{ buildAll(); }) );

// Load
window.addEventListener('DOMContentLoaded', ()=>{ loadLive(); });
</script>
</body>
</html>
